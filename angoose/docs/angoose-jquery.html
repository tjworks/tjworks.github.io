<!DOCTYPE html>

<html>
<head>
  <title>angoose-jquery.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="angoose-angular.html">
                angoose-angular.js
              </a>
            
              
              <a class="source" href="angoose-client.html">
                angoose-client.js
              </a>
            
              
              <a class="source" href="angoose-jquery.html">
                angoose-jquery.js
              </a>
            
              
              <a class="source" href="angoose-node.html">
                angoose-node.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>angoose-jquery.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>depdnencies: http, Q</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/****** jQuery plugin for Angoose Client *******/</span>
(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> $ ==<span class="string">'undefined'</span> &amp;&amp; <span class="keyword">typeof</span> jQuery == <span class="string">'undefined'</span>) {
        console.log(<span class="string">"No jQUery"</span>)
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span>(AngooseClient.client) <span class="keyword">return</span>;
    
    AngooseClient.client = <span class="string">'jquery'</span>;
    <span class="keyword">var</span> $ = $ || jQuery;
    <span class="keyword">var</span> $q = <span class="keyword">typeof</span>(Q) == <span class="string">'undefined'</span>? createQ() : Q;
    
    console.log(<span class="string">"##### Angoose Client for jQuery Initializing"</span>);
    
     AngooseClient.init({
                http: ajaxHttpWrapper(),
                promise: $q
            });
     <span class="function"><span class="keyword">function</span> <span class="title">ajaxHttpWrapper</span><span class="params">( )</span>{</span>
        <span class="keyword">var</span> ret = {};
        ret.post = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
            <span class="keyword">var</span> deferred = $q.defer();
            $.post.apply($, arguments).done(<span class="function"><span class="keyword">function</span><span class="params">(data, textStatus, jqXHR )</span>{</span>
                console.log(<span class="string">"Post return "</span>, data)
                deferred.resolve(  data );
            }).fail(<span class="function"><span class="keyword">function</span><span class="params">( jqXHR, textStatus, err)</span>{</span>
                deferred.reject(err);
            });
            <span class="keyword">return</span> deferred.promise;
        }
        <span class="keyword">return</span> ret;
    }
   
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>testing functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">$anget</span><span class="params">(serviceName)</span>{</span>
    <span class="keyword">return</span> angular.element(document).injector().get(serviceName)
}



<span class="comment">/** include Q for now */</span>
<span class="function"><span class="keyword">function</span> <span class="title">createQ</span><span class="params">()</span> {</span>
<span class="string">"use strict"</span>;

<span class="keyword">var</span> hasStacks = <span class="literal">false</span>;
<span class="keyword">try</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error();
} <span class="keyword">catch</span> (e) {
    hasStacks = !!e.stack;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>All code after this point will be filtered from stack traces reported
by Q.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> qStartingLine = captureLine();
<span class="keyword">var</span> qFileName;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>shims</p>
<p>used for fallback in &quot;allResolved&quot;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Use the fastest possible means to execute a task in a future turn
of the event loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> nextTick =(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>linked list of tasks (single, with head node)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> head = {task: <span class="keyword">void</span> <span class="number">0</span>, next: <span class="literal">null</span>};
    <span class="keyword">var</span> tail = head;
    <span class="keyword">var</span> flushing = <span class="literal">false</span>;
    <span class="keyword">var</span> requestTick = <span class="keyword">void</span> <span class="number">0</span>;
    <span class="keyword">var</span> isNodeJS = <span class="literal">false</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">flush</span><span class="params">()</span> {</span>
        <span class="comment">/* jshint loopfunc: true */</span>

        <span class="keyword">while</span> (head.next) {
            head = head.next;
            <span class="keyword">var</span> task = head.task;
            head.task = <span class="keyword">void</span> <span class="number">0</span>;
            <span class="keyword">var</span> domain = head.domain;

            <span class="keyword">if</span> (domain) {
                head.domain = <span class="keyword">void</span> <span class="number">0</span>;
                domain.enter();
            }

            <span class="keyword">try</span> {
                task();

            } <span class="keyword">catch</span> (e) {
                <span class="keyword">if</span> (isNodeJS) {</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>In node, uncaught exceptions are considered fatal errors.
Re-throw them synchronously to interrupt flushing!</p>
<p>Ensure continuation if the uncaught exception is suppressed
listening &quot;uncaughtException&quot; events (as domains does).
Continue in next event to avoid tick recursion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, <span class="number">0</span>);
                    <span class="keyword">if</span> (domain) {
                        domain.enter();
                    }

                    <span class="keyword">throw</span> e;

                } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>In browsers, uncaught exceptions are not fatal.
Re-throw them asynchronously to avoid slow-downs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                       <span class="keyword">throw</span> e;
                    }, <span class="number">0</span>);
                }
            }

            <span class="keyword">if</span> (domain) {
                domain.exit();
            }
        }

        flushing = <span class="literal">false</span>;
    }

    nextTick = <span class="function"><span class="keyword">function</span> <span class="params">(task)</span> {</span>
        tail = tail.next = {
            task: task,
            domain: isNodeJS &amp;&amp; process.domain,
            next: <span class="literal">null</span>
        };

        <span class="keyword">if</span> (!flushing) {
            flushing = <span class="literal">true</span>;
            requestTick();
        }
    };

    <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">"undefined"</span> &amp;&amp; process.nextTick) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Node.js before 0.9. Note that some fake-Node environments, like the
Mocha test runner, introduce a <code>process</code> global without a <code>nextTick</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        isNodeJS = <span class="literal">true</span>;

        requestTick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            process.nextTick(flush);
        };

    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate === <span class="string">"function"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>In IE10, Node.js 0.9+, or <a href="https://github.com/NobleJS/setImmediate">https://github.com/NobleJS/setImmediate</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">typeof</span> window !== <span class="string">"undefined"</span>) {
            requestTick = setImmediate.bind(window, flush);
        } <span class="keyword">else</span> {
            requestTick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                setImmediate(flush);
            };
        }

    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">"undefined"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>modern browsers
<a href="http://www.nonblocking.io/2011/06/windownexttick.html">http://www.nonblocking.io/2011/06/windownexttick.html</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
working message ports the first time a page loads.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        channel.port1.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        <span class="keyword">var</span> requestPortTick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Opera requires us to provide a message payload, regardless of
whether we use it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            channel.port2.postMessage(<span class="number">0</span>);
        };
        requestTick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            setTimeout(flush, <span class="number">0</span>);
            requestPortTick();
        };

    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>old browsers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        requestTick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            setTimeout(flush, <span class="number">0</span>);
        };
    }

    <span class="keyword">return</span> nextTick;
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Attempt to make generics safe in the face of downstream
modifications.
There is no situation where this is necessary.
If you need a security guarantee, these primordials need to be
deeply frozen anyway, and if you don’t need a security guarantee,
this is just plain paranoid.
However, this <strong>might</strong> have the nice side-effect of reducing the size of
the minified code by reducing x.call() to merely x()
See Mark Miller’s explanation of what this does.
<a href="http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming">http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> call = Function.call;
<span class="function"><span class="keyword">function</span> <span class="title">uncurryThis</span><span class="params">(f)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> call.apply(f, arguments);
    };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>This is equivalent, but slower:
uncurryThis = Function_bind.bind(Function_bind.call);
<a href="http://jsperf.com/uncurrythis">http://jsperf.com/uncurrythis</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> array_slice = uncurryThis(Array.prototype.slice);

<span class="keyword">var</span> array_reduce = uncurryThis(
    Array.prototype.reduce || <span class="function"><span class="keyword">function</span> <span class="params">(callback, basis)</span> {</span>
        <span class="keyword">var</span> index = <span class="number">0</span>,
            length = <span class="keyword">this</span>.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>concerning the initial value, if one is not provided</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>seek to the first value in the array, accounting
for the possibility that is is a sparse array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">do</span> {
                <span class="keyword">if</span> (index <span class="keyword">in</span> <span class="keyword">this</span>) {
                    basis = <span class="keyword">this</span>[index++];
                    <span class="keyword">break</span>;
                }
                <span class="keyword">if</span> (++index &gt;= length) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError();
                }
            } <span class="keyword">while</span> (<span class="number">1</span>);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>reduce</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">for</span> (; index &lt; length; index++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>account for the possibility that the array is sparse</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (index <span class="keyword">in</span> <span class="keyword">this</span>) {
                basis = callback(basis, <span class="keyword">this</span>[index], index);
            }
        }
        <span class="keyword">return</span> basis;
    }
);

<span class="keyword">var</span> array_indexOf = uncurryThis(
    Array.prototype.indexOf || <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>not a very good shim, but good enough for our one use of it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) {
            <span class="keyword">if</span> (<span class="keyword">this</span>[i] === value) {
                <span class="keyword">return</span> i;
            }
        }
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
);

<span class="keyword">var</span> array_map = uncurryThis(
    Array.prototype.map || <span class="function"><span class="keyword">function</span> <span class="params">(callback, thisp)</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> collect = [];
        array_reduce(self, <span class="function"><span class="keyword">function</span> <span class="params">(undefined, value, index)</span> {</span>
            collect.push(callback.call(thisp, value, index, self));
        }, <span class="keyword">void</span> <span class="number">0</span>);
        <span class="keyword">return</span> collect;
    }
);

<span class="keyword">var</span> object_create = Object.create || <span class="function"><span class="keyword">function</span> <span class="params">(prototype)</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">Type</span><span class="params">()</span> {</span> }
    Type.prototype = prototype;
    <span class="keyword">return</span> <span class="keyword">new</span> Type();
};

<span class="keyword">var</span> object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

<span class="keyword">var</span> object_keys = Object.keys || <span class="function"><span class="keyword">function</span> <span class="params">(object)</span> {</span>
    <span class="keyword">var</span> keys = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> object) {
        <span class="keyword">if</span> (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    <span class="keyword">return</span> keys;
};

<span class="keyword">var</span> object_toString = uncurryThis(Object.prototype.toString);

<span class="function"><span class="keyword">function</span> <span class="title">isObject</span><span class="params">(value)</span> {</span>
    <span class="keyword">return</span> value === Object(value);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>generator related shims</p>
<p>FIXME: Remove this function once ES6 generators are in SpiderMonkey.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">isStopIteration</span><span class="params">(exception)</span> {</span>
    <span class="keyword">return</span> (
        object_toString(exception) === <span class="string">"[object StopIteration]"</span> ||
        exception <span class="keyword">instanceof</span> QReturnValue
    );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>FIXME: Remove this helper and Q.return once ES6 generators are in
SpiderMonkey.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> QReturnValue;
<span class="keyword">if</span> (<span class="keyword">typeof</span> ReturnValue !== <span class="string">"undefined"</span>) {
    QReturnValue = ReturnValue;
} <span class="keyword">else</span> {
    QReturnValue = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        <span class="keyword">this</span>.value = value;
    };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
engine that has a deployed base of browsers that support generators.
However, SM&#39;s generators use the Python-inspired semantics of
outdated ES6 drafts.  We would like to support ES6, but we&#39;d also
like to make it possible to use generators in deployed browsers, so
we also support Python-style generators.  At some point we can remove
this block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> hasES6Generators;
<span class="keyword">try</span> {
    <span class="comment">/* jshint evil: true, nonew: false */</span>
    <span class="keyword">new</span> Function(<span class="string">"(function* (){ yield 1; })"</span>);
    hasES6Generators = <span class="literal">true</span>;
} <span class="keyword">catch</span> (e) {
    hasES6Generators = <span class="literal">false</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>long stack traces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> STACK_JUMP_SEPARATOR = <span class="string">"From previous event:"</span>;

<span class="function"><span class="keyword">function</span> <span class="title">makeStackTraceLong</span><span class="params">(error, promise)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>If possible, transform the error stack trace by removing Node and Q
cruft, then concatenating with the stack trace of <code>promise</code>. See #57.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (hasStacks &amp;&amp;
        promise.stack &amp;&amp;
        <span class="keyword">typeof</span> error === <span class="string">"object"</span> &amp;&amp;
        error !== <span class="literal">null</span> &amp;&amp;
        error.stack &amp;&amp;
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -<span class="number">1</span>
    ) {
        <span class="keyword">var</span> stacks = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> p = promise; !!p; p = p.source) {
            <span class="keyword">if</span> (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        <span class="keyword">var</span> concatedStacks = stacks.join(<span class="string">"\n"</span> + STACK_JUMP_SEPARATOR + <span class="string">"\n"</span>);
        error.stack = filterStackString(concatedStacks);
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">filterStackString</span><span class="params">(stackString)</span> {</span>
    <span class="keyword">var</span> lines = stackString.split(<span class="string">"\n"</span>);
    <span class="keyword">var</span> desiredLines = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lines.length; ++i) {
        <span class="keyword">var</span> line = lines[i];

        <span class="keyword">if</span> (!isInternalFrame(line) &amp;&amp; !isNodeFrame(line) &amp;&amp; line) {
            desiredLines.push(line);
        }
    }
    <span class="keyword">return</span> desiredLines.join(<span class="string">"\n"</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">isNodeFrame</span><span class="params">(stackLine)</span> {</span>
    <span class="keyword">return</span> stackLine.indexOf(<span class="string">"(module.js:"</span>) !== -<span class="number">1</span> ||
           stackLine.indexOf(<span class="string">"(node.js:"</span>) !== -<span class="number">1</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">getFileNameAndLineNumber</span><span class="params">(stackLine)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Named functions: &quot;at functionName (filename:lineNumber:columnNumber)&quot;
In IE10 function name can have spaces (&quot;Anonymous function&quot;) O_o</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> attempt1 = <span class="regexp">/at .+ \((.+):(\d+):(?:\d+)\)$/</span>.exec(stackLine);
    <span class="keyword">if</span> (attempt1) {
        <span class="keyword">return</span> [attempt1[<span class="number">1</span>], Number(attempt1[<span class="number">2</span>])];
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Anonymous functions: &quot;at filename:lineNumber:columnNumber&quot;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> attempt2 = <span class="regexp">/at ([^ ]+):(\d+):(?:\d+)$/</span>.exec(stackLine);
    <span class="keyword">if</span> (attempt2) {
        <span class="keyword">return</span> [attempt2[<span class="number">1</span>], Number(attempt2[<span class="number">2</span>])];
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Firefox style: &quot;function@filename:lineNumber or @filename:lineNumber&quot;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> attempt3 = <span class="regexp">/.*@(.+):(\d+)$/</span>.exec(stackLine);
    <span class="keyword">if</span> (attempt3) {
        <span class="keyword">return</span> [attempt3[<span class="number">1</span>], Number(attempt3[<span class="number">2</span>])];
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">isInternalFrame</span><span class="params">(stackLine)</span> {</span>
    <span class="keyword">var</span> fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    <span class="keyword">if</span> (!fileNameAndLineNumber) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">var</span> fileName = fileNameAndLineNumber[<span class="number">0</span>];
    <span class="keyword">var</span> lineNumber = fileNameAndLineNumber[<span class="number">1</span>];

    <span class="keyword">return</span> fileName === qFileName &amp;&amp;
        lineNumber &gt;= qStartingLine &amp;&amp;
        lineNumber &lt;= qEndingLine;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>discover own file name and line number range for filtering stack
traces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">captureLine</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (!hasStacks) {
        <span class="keyword">return</span>;
    }

    <span class="keyword">try</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error();
    } <span class="keyword">catch</span> (e) {
        <span class="keyword">var</span> lines = e.stack.split(<span class="string">"\n"</span>);
        <span class="keyword">var</span> firstLine = lines[<span class="number">0</span>].indexOf(<span class="string">"@"</span>) &gt; <span class="number">0</span> ? lines[<span class="number">1</span>] : lines[<span class="number">2</span>];
        <span class="keyword">var</span> fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        <span class="keyword">if</span> (!fileNameAndLineNumber) {
            <span class="keyword">return</span>;
        }

        qFileName = fileNameAndLineNumber[<span class="number">0</span>];
        <span class="keyword">return</span> fileNameAndLineNumber[<span class="number">1</span>];
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">deprecate</span><span class="params">(callback, name, alternative)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> console !== <span class="string">"undefined"</span> &amp;&amp;
            <span class="keyword">typeof</span> console.warn === <span class="string">"function"</span>) {
            console.warn(name + <span class="string">" is deprecated, use "</span> + alternative +
                         <span class="string">" instead."</span>, <span class="keyword">new</span> Error(<span class="string">""</span>).stack);
        }
        <span class="keyword">return</span> callback.apply(callback, arguments);
    };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>end of shims
beginning of real work</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">Q</span><span class="params">(value)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>If the object is already a Promise, return it directly.  This enables
the resolve function to both be used to created references from objects,
but to tolerably coerce non-promises to promises.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (isPromise(value)) {
        <span class="keyword">return</span> value;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>assimilate thenables</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (isPromiseAlike(value)) {
        <span class="keyword">return</span> coerce(value);
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> fulfill(value);
    }
}
Q.resolve = Q;

<span class="comment">/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */</span>
Q.nextTick = nextTick;

<span class="comment">/**
 * Controls whether or not long stack traces will be on
 */</span>
Q.longStackSupport = <span class="literal">false</span>;

<span class="comment">/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */</span>
Q.defer = defer;
<span class="function"><span class="keyword">function</span> <span class="title">defer</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>if &quot;messages&quot; is an &quot;Array&quot;, that indicates that the promise has not yet
been resolved.  If it is &quot;undefined&quot;, it has been resolved.  Each
element of the messages array is itself an array of complete arguments to
forward to the resolved promise.  We coerce the resolution value to a
promise using the <code>resolve</code> function because it handles both fully
non-thenable values and other thenables gracefully.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> messages = [], progressListeners = [], resolvedPromise;

    <span class="keyword">var</span> deferred = object_create(defer.prototype);
    <span class="keyword">var</span> promise = object_create(Promise.prototype);

    promise.promiseDispatch = <span class="function"><span class="keyword">function</span> <span class="params">(resolve, op, operands)</span> {</span>
        <span class="keyword">var</span> args = array_slice(arguments);
        <span class="keyword">if</span> (messages) {
            messages.push(args);
            <span class="keyword">if</span> (op === <span class="string">"when"</span> &amp;&amp; operands[<span class="number">1</span>]) { <span class="comment">// progress operand</span>
                progressListeners.push(operands[<span class="number">1</span>]);
            }
        } <span class="keyword">else</span> {
            nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>XXX deprecated</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    promise.valueOf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (messages) {
            <span class="keyword">return</span> promise;
        }
        <span class="keyword">var</span> nearerValue = nearer(resolvedPromise);
        <span class="keyword">if</span> (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; <span class="comment">// shorten chain</span>
        }
        <span class="keyword">return</span> nearerValue;
    };

    promise.inspect = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (!resolvedPromise) {
            <span class="keyword">return</span> { state: <span class="string">"pending"</span> };
        }
        <span class="keyword">return</span> resolvedPromise.inspect();
    };

    <span class="keyword">if</span> (Q.longStackSupport &amp;&amp; hasStacks) {
        <span class="keyword">try</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error();
        } <span class="keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>NOTE: don&#39;t try to use <code>Error.captureStackTrace</code> or transfer the
accessor around; that causes memory leaks as per GH-111. Just
reify the stack trace as a string ASAP.</p>
<p>At the same time, cut off the first line; it&#39;s always just
&quot;[object Promise]\n&quot;, as per the <code>toString</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            promise.stack = e.stack.substring(e.stack.indexOf(<span class="string">"\n"</span>) + <span class="number">1</span>);
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>NOTE: we do the checks for <code>resolvedPromise</code> in each method, instead of
consolidating them into <code>become</code>, since otherwise we&#39;d create new
promises with the lines <code>become(whatever(value))</code>. See e.g. GH-252.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">become</span><span class="params">(newPromise)</span> {</span>
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, <span class="function"><span class="keyword">function</span> <span class="params">(undefined, message)</span> {</span>
            nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, <span class="keyword">void</span> <span class="number">0</span>);

        messages = <span class="keyword">void</span> <span class="number">0</span>;
        progressListeners = <span class="keyword">void</span> <span class="number">0</span>;
    }

    deferred.promise = promise;
    deferred.resolve = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        <span class="keyword">if</span> (resolvedPromise) {
            <span class="keyword">return</span>;
        }

        become(Q(value));
    };

    deferred.fulfill = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        <span class="keyword">if</span> (resolvedPromise) {
            <span class="keyword">return</span>;
        }

        become(fulfill(value));
    };
    deferred.reject = <span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> {</span>
        <span class="keyword">if</span> (resolvedPromise) {
            <span class="keyword">return</span>;
        }

        become(reject(reason));
    };
    deferred.notify = <span class="function"><span class="keyword">function</span> <span class="params">(progress)</span> {</span>
        <span class="keyword">if</span> (resolvedPromise) {
            <span class="keyword">return</span>;
        }

        array_reduce(progressListeners, <span class="function"><span class="keyword">function</span> <span class="params">(undefined, progressListener)</span> {</span>
            nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                progressListener(progress);
            });
        }, <span class="keyword">void</span> <span class="number">0</span>);
    };

    <span class="keyword">return</span> deferred;
}

<span class="comment">/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */</span>
defer.prototype.makeNodeResolver = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(error, value)</span> {</span>
        <span class="keyword">if</span> (error) {
            self.reject(error);
        } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length &gt; <span class="number">2</span>) {
            self.resolve(array_slice(arguments, <span class="number">1</span>));
        } <span class="keyword">else</span> {
            self.resolve(value);
        }
    };
};

<span class="comment">/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */</span>
Q.promise = promise;
<span class="function"><span class="keyword">function</span> <span class="title">promise</span><span class="params">(resolver)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> resolver !== <span class="string">"function"</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"resolver must be a function."</span>);
    }
    <span class="keyword">var</span> deferred = defer();
    <span class="keyword">try</span> {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } <span class="keyword">catch</span> (reason) {
        deferred.reject(reason);
    }
    <span class="keyword">return</span> deferred.promise;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>XXX experimental.  This method is a way to denote that a local value is
serializable and should be immediately dispatched to a remote upon request,
instead of passing a reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.passByCopy = <span class="function"><span class="keyword">function</span> <span class="params">(object)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>freeze(object);
passByCopies.set(object, true);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> object;
};

Promise.prototype.passByCopy = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>freeze(object);
passByCopies.set(object, true);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */</span>
Q.join = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
    <span class="keyword">return</span> Q(x).join(y);
};

Promise.prototype.join = <span class="function"><span class="keyword">function</span> <span class="params">(that)</span> {</span>
    <span class="keyword">return</span> Q([<span class="keyword">this</span>, that]).spread(<span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> {</span>
        <span class="keyword">if</span> (x === y) {</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>TODO: &quot;===&quot; should be Object.is or equiv</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> x;
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Can't join: not the same: "</span> + x + <span class="string">" "</span> + y);
        }
    });
};

<span class="comment">/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */</span>
Q.race = race;
<span class="function"><span class="keyword">function</span> <span class="title">race</span><span class="params">(answerPs)</span> {</span>
    <span class="keyword">return</span> promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Switch to this once we can assume at least ES5
answerPs.forEach(function(answerP) {
    Q(answerP).then(resolve, reject);
});
Use this in the meantime</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = answerPs.length; i &lt; len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(Q.race);
};

<span class="comment">/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */</span>
Q.makePromise = Promise;
<span class="function"><span class="keyword">function</span> <span class="title">Promise</span><span class="params">(descriptor, fallback, inspect)</span> {</span>
    <span class="keyword">if</span> (fallback === <span class="keyword">void</span> <span class="number">0</span>) {
        fallback = <span class="function"><span class="keyword">function</span> <span class="params">(op)</span> {</span>
            <span class="keyword">return</span> reject(<span class="keyword">new</span> Error(
                <span class="string">"Promise does not support operation: "</span> + op
            ));
        };
    }
    <span class="keyword">if</span> (inspect === <span class="keyword">void</span> <span class="number">0</span>) {
        inspect = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> {state: <span class="string">"unknown"</span>};
        };
    }

    <span class="keyword">var</span> promise = object_create(Promise.prototype);

    promise.promiseDispatch = <span class="function"><span class="keyword">function</span> <span class="params">(resolve, op, args)</span> {</span>
        <span class="keyword">var</span> result;
        <span class="keyword">try</span> {
            <span class="keyword">if</span> (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } <span class="keyword">else</span> {
                result = fallback.call(promise, op, args);
            }
        } <span class="keyword">catch</span> (exception) {
            result = reject(exception);
        }
        <span class="keyword">if</span> (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>XXX deprecated <code>valueOf</code> and <code>exception</code> support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (inspect) {
        <span class="keyword">var</span> inspected = inspect();
        <span class="keyword">if</span> (inspected.state === <span class="string">"rejected"</span>) {
            promise.exception = inspected.reason;
        }

        promise.valueOf = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> inspected = inspect();
            <span class="keyword">if</span> (inspected.state === <span class="string">"pending"</span> ||
                inspected.state === <span class="string">"rejected"</span>) {
                <span class="keyword">return</span> promise;
            }
            <span class="keyword">return</span> inspected.value;
        };
    }

    <span class="keyword">return</span> promise;
}

Promise.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="string">"[object Promise]"</span>;
};

Promise.prototype.then = <span class="function"><span class="keyword">function</span> <span class="params">(fulfilled, rejected, progressed)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> deferred = defer();
    <span class="keyword">var</span> done = <span class="literal">false</span>;   <span class="comment">// ensure the untrusted promise makes at most a</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>single call to one of the callbacks</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">_fulfilled</span><span class="params">(value)</span> {</span>
        <span class="keyword">try</span> {
            <span class="keyword">return</span> <span class="keyword">typeof</span> fulfilled === <span class="string">"function"</span> ? fulfilled(value) : value;
        } <span class="keyword">catch</span> (exception) {
            <span class="keyword">return</span> reject(exception);
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">_rejected</span><span class="params">(exception)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> rejected === <span class="string">"function"</span>) {
            makeStackTraceLong(exception, self);
            <span class="keyword">try</span> {
                <span class="keyword">return</span> rejected(exception);
            } <span class="keyword">catch</span> (newException) {
                <span class="keyword">return</span> reject(newException);
            }
        }
        <span class="keyword">return</span> reject(exception);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">_progressed</span><span class="params">(value)</span> {</span>
        <span class="keyword">return</span> <span class="keyword">typeof</span> progressed === <span class="string">"function"</span> ? progressed(value) : value;
    }

    nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        self.promiseDispatch(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
            <span class="keyword">if</span> (done) {
                <span class="keyword">return</span>;
            }
            done = <span class="literal">true</span>;

            deferred.resolve(_fulfilled(value));
        }, <span class="string">"when"</span>, [<span class="function"><span class="keyword">function</span> <span class="params">(exception)</span> {</span>
            <span class="keyword">if</span> (done) {
                <span class="keyword">return</span>;
            }
            done = <span class="literal">true</span>;

            deferred.resolve(_rejected(exception));
        }]);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Progress propagator need to be attached in the current tick.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    self.promiseDispatch(<span class="keyword">void</span> <span class="number">0</span>, <span class="string">"when"</span>, [<span class="keyword">void</span> <span class="number">0</span>, <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        <span class="keyword">var</span> newValue;
        <span class="keyword">var</span> threw = <span class="literal">false</span>;
        <span class="keyword">try</span> {
            newValue = _progressed(value);
        } <span class="keyword">catch</span> (e) {
            threw = <span class="literal">true</span>;
            <span class="keyword">if</span> (Q.onerror) {
                Q.onerror(e);
            } <span class="keyword">else</span> {
                <span class="keyword">throw</span> e;
            }
        }

        <span class="keyword">if</span> (!threw) {
            deferred.notify(newValue);
        }
    }]);

    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */</span>
Q.when = when;
<span class="function"><span class="keyword">function</span> <span class="title">when</span><span class="params">(value, fulfilled, rejected, progressed)</span> {</span>
    <span class="keyword">return</span> Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> value; });
};

Q.thenResolve = <span class="function"><span class="keyword">function</span> <span class="params">(promise, value)</span> {</span>
    <span class="keyword">return</span> Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = <span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">throw</span> reason; });
};

Q.thenReject = <span class="function"><span class="keyword">function</span> <span class="params">(promise, reason)</span> {</span>
    <span class="keyword">return</span> Q(promise).thenReject(reason);
};

<span class="comment">/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>XXX should we re-do this?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.nearer = nearer;
<span class="function"><span class="keyword">function</span> <span class="title">nearer</span><span class="params">(value)</span> {</span>
    <span class="keyword">if</span> (isPromise(value)) {
        <span class="keyword">var</span> inspected = value.inspect();
        <span class="keyword">if</span> (inspected.state === <span class="string">"fulfilled"</span>) {
            <span class="keyword">return</span> inspected.value;
        }
    }
    <span class="keyword">return</span> value;
}

<span class="comment">/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */</span>
Q.isPromise = isPromise;
<span class="function"><span class="keyword">function</span> <span class="title">isPromise</span><span class="params">(object)</span> {</span>
    <span class="keyword">return</span> isObject(object) &amp;&amp;
        <span class="keyword">typeof</span> object.promiseDispatch === <span class="string">"function"</span> &amp;&amp;
        <span class="keyword">typeof</span> object.inspect === <span class="string">"function"</span>;
}

Q.isPromiseAlike = isPromiseAlike;
<span class="function"><span class="keyword">function</span> <span class="title">isPromiseAlike</span><span class="params">(object)</span> {</span>
    <span class="keyword">return</span> isObject(object) &amp;&amp; <span class="keyword">typeof</span> object.then === <span class="string">"function"</span>;
}

<span class="comment">/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */</span>
Q.isPending = isPending;
<span class="function"><span class="keyword">function</span> <span class="title">isPending</span><span class="params">(object)</span> {</span>
    <span class="keyword">return</span> isPromise(object) &amp;&amp; object.inspect().state === <span class="string">"pending"</span>;
}

Promise.prototype.isPending = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.inspect().state === <span class="string">"pending"</span>;
};

<span class="comment">/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */</span>
Q.isFulfilled = isFulfilled;
<span class="function"><span class="keyword">function</span> <span class="title">isFulfilled</span><span class="params">(object)</span> {</span>
    <span class="keyword">return</span> !isPromise(object) || object.inspect().state === <span class="string">"fulfilled"</span>;
}

Promise.prototype.isFulfilled = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.inspect().state === <span class="string">"fulfilled"</span>;
};

<span class="comment">/**
 * @returns whether the given object is a rejected promise.
 */</span>
Q.isRejected = isRejected;
<span class="function"><span class="keyword">function</span> <span class="title">isRejected</span><span class="params">(object)</span> {</span>
    <span class="keyword">return</span> isPromise(object) &amp;&amp; object.inspect().state === <span class="string">"rejected"</span>;
}

Promise.prototype.isRejected = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.inspect().state === <span class="string">"rejected"</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>// BEGIN UNHANDLED REJECTION TRACKING</p>
<p>This promise library consumes exceptions thrown in handlers so they can be
handled by a subsequent promise.  The exceptions get added to this array when
they are created, and removed when they are handled.  Note that in ES6 or
shimmed environments, this would naturally be a <code>Set</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> unhandledReasons = [];
<span class="keyword">var</span> unhandledRejections = [];
<span class="keyword">var</span> unhandledReasonsDisplayed = <span class="literal">false</span>;
<span class="keyword">var</span> trackUnhandledRejections = <span class="literal">true</span>;
<span class="function"><span class="keyword">function</span> <span class="title">displayUnhandledReasons</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (
        !unhandledReasonsDisplayed &amp;&amp;
        <span class="keyword">typeof</span> window !== <span class="string">"undefined"</span> &amp;&amp;
        window.console
    ) {
        console.warn(<span class="string">"[Q] Unhandled rejection reasons (should be empty):"</span>,
                     unhandledReasons);
    }

    unhandledReasonsDisplayed = <span class="literal">true</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">logUnhandledReasons</span><span class="params">()</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; unhandledReasons.length; i++) {
        <span class="keyword">var</span> reason = unhandledReasons[i];
        console.warn(<span class="string">"Unhandled rejection reason:"</span>, reason);
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">resetUnhandledRejections</span><span class="params">()</span> {</span>
    unhandledReasons.length = <span class="number">0</span>;
    unhandledRejections.length = <span class="number">0</span>;
    unhandledReasonsDisplayed = <span class="literal">false</span>;

    <span class="keyword">if</span> (!trackUnhandledRejections) {
        trackUnhandledRejections = <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Show unhandled rejection reasons if Node exits without handling an
outstanding rejection.  (Note that Browserify presently produces a
<code>process</code> global without the <code>EventEmitter</code> <code>on</code> method.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">"undefined"</span> &amp;&amp; process.on) {
            process.on(<span class="string">"exit"</span>, logUnhandledReasons);
        }
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">trackRejection</span><span class="params">(promise, reason)</span> {</span>
    <span class="keyword">if</span> (!trackUnhandledRejections) {
        <span class="keyword">return</span>;
    }

    unhandledRejections.push(promise);
    <span class="keyword">if</span> (reason &amp;&amp; <span class="keyword">typeof</span> reason.stack !== <span class="string">"undefined"</span>) {
        unhandledReasons.push(reason.stack);
    } <span class="keyword">else</span> {
        unhandledReasons.push(<span class="string">"(no stack) "</span> + reason);
    }
    displayUnhandledReasons();
}

<span class="function"><span class="keyword">function</span> <span class="title">untrackRejection</span><span class="params">(promise)</span> {</span>
    <span class="keyword">if</span> (!trackUnhandledRejections) {
        <span class="keyword">return</span>;
    }

    <span class="keyword">var</span> at = array_indexOf(unhandledRejections, promise);
    <span class="keyword">if</span> (at !== -<span class="number">1</span>) {
        unhandledRejections.splice(at, <span class="number">1</span>);
        unhandledReasons.splice(at, <span class="number">1</span>);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Make a copy so that consumers can&#39;t interfere with our internal state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    resetUnhandledRejections();
    <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">"undefined"</span> &amp;&amp; process.on) {
        process.removeListener(<span class="string">"exit"</span>, logUnhandledReasons);
    }
    trackUnhandledRejections = <span class="literal">false</span>;
};

resetUnhandledRejections();</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>// END UNHANDLED REJECTION TRACKING</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */</span>
Q.reject = reject;
<span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">(reason)</span> {</span>
    <span class="keyword">var</span> rejection = Promise({
        <span class="string">"when"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(rejected)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>note that the error has been handled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (rejected) {
                untrackRejection(<span class="keyword">this</span>);
            }
            <span class="keyword">return</span> rejected ? rejected(reason) : <span class="keyword">this</span>;
        }
    }, <span class="function"><span class="keyword">function</span> <span class="title">fallback</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }, <span class="function"><span class="keyword">function</span> <span class="title">inspect</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> { state: <span class="string">"rejected"</span>, reason: reason };
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Note that the reason has not been handled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    trackRejection(rejection, reason);

    <span class="keyword">return</span> rejection;
}

<span class="comment">/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */</span>
Q.fulfill = fulfill;
<span class="function"><span class="keyword">function</span> <span class="title">fulfill</span><span class="params">(value)</span> {</span>
    <span class="keyword">return</span> Promise({
        <span class="string">"when"</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> value;
        },
        <span class="string">"get"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
            <span class="keyword">return</span> value[name];
        },
        <span class="string">"set"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(name, rhs)</span> {</span>
            value[name] = rhs;
        },
        <span class="string">"delete"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
            <span class="keyword">delete</span> value[name];
        },
        <span class="string">"post"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(name, args)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Mark Miller proposes that post with no name should apply a
promised function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (name === <span class="literal">null</span> || name === <span class="keyword">void</span> <span class="number">0</span>) {
                <span class="keyword">return</span> value.apply(<span class="keyword">void</span> <span class="number">0</span>, args);
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> value[name].apply(value, args);
            }
        },
        <span class="string">"apply"</span>: <span class="function"><span class="keyword">function</span> <span class="params">(thisp, args)</span> {</span>
            <span class="keyword">return</span> value.apply(thisp, args);
        },
        <span class="string">"keys"</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> object_keys(value);
        }
    }, <span class="keyword">void</span> <span class="number">0</span>, <span class="function"><span class="keyword">function</span> <span class="title">inspect</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> { state: <span class="string">"fulfilled"</span>, value: value };
    });
}

<span class="comment">/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">coerce</span><span class="params">(promise)</span> {</span>
    <span class="keyword">var</span> deferred = defer();
    nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">try</span> {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } <span class="keyword">catch</span> (exception) {
            deferred.reject(exception);
        }
    });
    <span class="keyword">return</span> deferred.promise;
}

<span class="comment">/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */</span>
Q.master = master;
<span class="function"><span class="keyword">function</span> <span class="title">master</span><span class="params">(object)</span> {</span>
    <span class="keyword">return</span> Promise({
        <span class="string">"isDef"</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}
    }, <span class="function"><span class="keyword">function</span> <span class="title">fallback</span><span class="params">(op, args)</span> {</span>
        <span class="keyword">return</span> dispatch(object, op, args);
    }, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> Q(object).inspect();
    });
}

<span class="comment">/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */</span>
Q.spread = spread;
<span class="function"><span class="keyword">function</span> <span class="title">spread</span><span class="params">(value, fulfilled, rejected)</span> {</span>
    <span class="keyword">return</span> Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = <span class="function"><span class="keyword">function</span> <span class="params">(fulfilled, rejected)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.all().then(<span class="function"><span class="keyword">function</span> <span class="params">(array)</span> {</span>
        <span class="keyword">return</span> fulfilled.apply(<span class="keyword">void</span> <span class="number">0</span>, array);
    }, rejected);
};

<span class="comment">/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */</span>
Q.async = async;
<span class="function"><span class="keyword">function</span> <span class="title">async</span><span class="params">(makeGenerator)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>when verb is &quot;send&quot;, arg is a value
when verb is &quot;throw&quot;, arg is an exception</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="function"><span class="keyword">function</span> <span class="title">continuer</span><span class="params">(verb, arg)</span> {</span>
            <span class="keyword">var</span> result;
            <span class="keyword">if</span> (hasES6Generators) {
                <span class="keyword">try</span> {
                    result = generator[verb](arg);
                } <span class="keyword">catch</span> (exception) {
                    <span class="keyword">return</span> reject(exception);
                }
                <span class="keyword">if</span> (result.done) {
                    <span class="keyword">return</span> result.value;
                } <span class="keyword">else</span> {
                    <span class="keyword">return</span> when(result.value, callback, errback);
                }
            } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>FIXME: Remove this case when SM does ES6 generators.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">try</span> {
                    result = generator[verb](arg);
                } <span class="keyword">catch</span> (exception) {
                    <span class="keyword">if</span> (isStopIteration(exception)) {
                        <span class="keyword">return</span> exception.value;
                    } <span class="keyword">else</span> {
                        <span class="keyword">return</span> reject(exception);
                    }
                }
                <span class="keyword">return</span> when(result, callback, errback);
            }
        }
        <span class="keyword">var</span> generator = makeGenerator.apply(<span class="keyword">this</span>, arguments);
        <span class="keyword">var</span> callback = continuer.bind(continuer, <span class="string">"next"</span>);
        <span class="keyword">var</span> errback = continuer.bind(continuer, <span class="string">"throw"</span>);
        <span class="keyword">return</span> callback();
    };
}

<span class="comment">/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */</span>
Q.spawn = spawn;
<span class="function"><span class="keyword">function</span> <span class="title">spawn</span><span class="params">(makeGenerator)</span> {</span>
    Q.done(Q.async(makeGenerator)());
}</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>FIXME: Remove this interface once ES6 generators are in SpiderMonkey.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */</span>
Q[<span class="string">"return"</span>] = _return;
<span class="function"><span class="keyword">function</span> <span class="title">_return</span><span class="params">(value)</span> {</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> QReturnValue(value);
}

<span class="comment">/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */</span>
Q.promised = promised;
<span class="function"><span class="keyword">function</span> <span class="title">promised</span><span class="params">(callback)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> spread([<span class="keyword">this</span>, all(arguments)], <span class="function"><span class="keyword">function</span> <span class="params">(self, args)</span> {</span>
            <span class="keyword">return</span> callback.apply(self, args);
        });
    };
}

<span class="comment">/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */</span>
Q.dispatch = dispatch;
<span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">(object, op, args)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="params">(op, args)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> deferred = defer();
    nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        self.promiseDispatch(deferred.resolve, op, args);
    });
    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */</span>
Q.get = <span class="function"><span class="keyword">function</span> <span class="params">(object, key)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"get"</span>, [key]);
};

Promise.prototype.get = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"get"</span>, [key]);
};

<span class="comment">/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */</span>
Q.set = <span class="function"><span class="keyword">function</span> <span class="params">(object, key, value)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"set"</span>, [key, value]);
};

Promise.prototype.set = <span class="function"><span class="keyword">function</span> <span class="params">(key, value)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"set"</span>, [key, value]);
};

<span class="comment">/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */</span>
Q.del = <span class="comment">// XXX legacy</span>
Q[<span class="string">"delete"</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(object, key)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"delete"</span>, [key]);
};

Promise.prototype.del = <span class="comment">// XXX legacy</span>
Promise.prototype[<span class="string">"delete"</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"delete"</span>, [key]);
};

<span class="comment">/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>bound locally because it is used by other methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.mapply = <span class="comment">// XXX As proposed by "Redsandro"</span>
Q.post = <span class="function"><span class="keyword">function</span> <span class="params">(object, name, args)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"post"</span>, [name, args]);
};

Promise.prototype.mapply = <span class="comment">// XXX As proposed by "Redsandro"</span>
Promise.prototype.post = <span class="function"><span class="keyword">function</span> <span class="params">(name, args)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"post"</span>, [name, args]);
};

<span class="comment">/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */</span>
Q.send = <span class="comment">// XXX Mark Miller's proposed parlance</span>
Q.mcall = <span class="comment">// XXX As proposed by "Redsandro"</span>
Q.invoke = <span class="function"><span class="keyword">function</span> <span class="params">(object, name <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"post"</span>, [name, array_slice(arguments, <span class="number">2</span>)]);
};

Promise.prototype.send = <span class="comment">// XXX Mark Miller's proposed parlance</span>
Promise.prototype.mcall = <span class="comment">// XXX As proposed by "Redsandro"</span>
Promise.prototype.invoke = <span class="function"><span class="keyword">function</span> <span class="params">(name <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"post"</span>, [name, array_slice(arguments, <span class="number">1</span>)]);
};

<span class="comment">/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */</span>
Q.fapply = <span class="function"><span class="keyword">function</span> <span class="params">(object, args)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"apply"</span>, [<span class="keyword">void</span> <span class="number">0</span>, args]);
};

Promise.prototype.fapply = <span class="function"><span class="keyword">function</span> <span class="params">(args)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"apply"</span>, [<span class="keyword">void</span> <span class="number">0</span>, args]);
};

<span class="comment">/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */</span>
Q[<span class="string">"try"</span>] =
Q.fcall = <span class="function"><span class="keyword">function</span> <span class="params">(object <span class="comment">/* ...args*/</span>)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"apply"</span>, [<span class="keyword">void</span> <span class="number">0</span>, array_slice(arguments, <span class="number">1</span>)]);
};

Promise.prototype.fcall = <span class="function"><span class="keyword">function</span> <span class="params">(<span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"apply"</span>, [<span class="keyword">void</span> <span class="number">0</span>, array_slice(arguments)]);
};

<span class="comment">/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */</span>
Q.fbind = <span class="function"><span class="keyword">function</span> <span class="params">(object <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> promise = Q(object);
    <span class="keyword">var</span> args = array_slice(arguments, <span class="number">1</span>);
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fbound</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> promise.dispatch(<span class="string">"apply"</span>, [
            <span class="keyword">this</span>,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = <span class="function"><span class="keyword">function</span> <span class="params">(<span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> promise = <span class="keyword">this</span>;
    <span class="keyword">var</span> args = array_slice(arguments);
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fbound</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> promise.dispatch(<span class="string">"apply"</span>, [
            <span class="keyword">this</span>,
            args.concat(array_slice(arguments))
        ]);
    };
};

<span class="comment">/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */</span>
Q.keys = <span class="function"><span class="keyword">function</span> <span class="params">(object)</span> {</span>
    <span class="keyword">return</span> Q(object).dispatch(<span class="string">"keys"</span>, []);
};

Promise.prototype.keys = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.dispatch(<span class="string">"keys"</span>, []);
};

<span class="comment">/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>By Mark Miller
<a href="http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&amp;rev=1308776521#allfulfilled">http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&amp;rev=1308776521#allfulfilled</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Q.all = all;
<span class="function"><span class="keyword">function</span> <span class="title">all</span><span class="params">(promises)</span> {</span>
    <span class="keyword">return</span> when(promises, <span class="function"><span class="keyword">function</span> <span class="params">(promises)</span> {</span>
        <span class="keyword">var</span> countDown = <span class="number">0</span>;
        <span class="keyword">var</span> deferred = defer();
        array_reduce(promises, <span class="function"><span class="keyword">function</span> <span class="params">(undefined, promise, index)</span> {</span>
            <span class="keyword">var</span> snapshot;
            <span class="keyword">if</span> (
                isPromise(promise) &amp;&amp;
                (snapshot = promise.inspect()).state === <span class="string">"fulfilled"</span>
            ) {
                promises[index] = snapshot.value;
            } <span class="keyword">else</span> {
                ++countDown;
                when(
                    promise,
                    <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
                        promises[index] = value;
                        <span class="keyword">if</span> (--countDown === <span class="number">0</span>) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    <span class="function"><span class="keyword">function</span> <span class="params">(progress)</span> {</span>
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, <span class="keyword">void</span> <span class="number">0</span>);
        <span class="keyword">if</span> (countDown === <span class="number">0</span>) {
            deferred.resolve(promises);
        }
        <span class="keyword">return</span> deferred.promise;
    });
}

Promise.prototype.all = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> all(<span class="keyword">this</span>);
};

<span class="comment">/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */</span>
Q.allResolved = deprecate(allResolved, <span class="string">"allResolved"</span>, <span class="string">"allSettled"</span>);
<span class="function"><span class="keyword">function</span> <span class="title">allResolved</span><span class="params">(promises)</span> {</span>
    <span class="keyword">return</span> when(promises, <span class="function"><span class="keyword">function</span> <span class="params">(promises)</span> {</span>
        promises = array_map(promises, Q);
        <span class="keyword">return</span> when(all(array_map(promises, <span class="function"><span class="keyword">function</span> <span class="params">(promise)</span> {</span>
            <span class="keyword">return</span> when(promise, noop, noop);
        })), <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> promises;
        });
    });
}

Promise.prototype.allResolved = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> allResolved(<span class="keyword">this</span>);
};

<span class="comment">/**
 * @see Promise#allSettled
 */</span>
Q.allSettled = allSettled;
<span class="function"><span class="keyword">function</span> <span class="title">allSettled</span><span class="params">(promises)</span> {</span>
    <span class="keyword">return</span> Q(promises).allSettled();
}

<span class="comment">/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */</span>
Promise.prototype.allSettled = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">(promises)</span> {</span>
        <span class="keyword">return</span> all(array_map(promises, <span class="function"><span class="keyword">function</span> <span class="params">(promise)</span> {</span>
            promise = Q(promise);
            <span class="function"><span class="keyword">function</span> <span class="title">regardless</span><span class="params">()</span> {</span>
                <span class="keyword">return</span> promise.inspect();
            }
            <span class="keyword">return</span> promise.then(regardless, regardless);
        }));
    });
};

<span class="comment">/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */</span>
Q.fail = <span class="comment">// XXX legacy</span>
Q[<span class="string">"catch"</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(object, rejected)</span> {</span>
    <span class="keyword">return</span> Q(object).then(<span class="keyword">void</span> <span class="number">0</span>, rejected);
};

Promise.prototype.fail = <span class="comment">// XXX legacy</span>
Promise.prototype[<span class="string">"catch"</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(rejected)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="keyword">void</span> <span class="number">0</span>, rejected);
};

<span class="comment">/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */</span>
Q.progress = progress;
<span class="function"><span class="keyword">function</span> <span class="title">progress</span><span class="params">(object, progressed)</span> {</span>
    <span class="keyword">return</span> Q(object).then(<span class="keyword">void</span> <span class="number">0</span>, <span class="keyword">void</span> <span class="number">0</span>, progressed);
}

Promise.prototype.progress = <span class="function"><span class="keyword">function</span> <span class="params">(progressed)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="keyword">void</span> <span class="number">0</span>, <span class="keyword">void</span> <span class="number">0</span>, progressed);
};

<span class="comment">/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */</span>
Q.fin = <span class="comment">// XXX legacy</span>
Q[<span class="string">"finally"</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(object, callback)</span> {</span>
    <span class="keyword">return</span> Q(object)[<span class="string">"finally"</span>](callback);
};

Promise.prototype.fin = <span class="comment">// XXX legacy</span>
Promise.prototype[<span class="string">"finally"</span>] = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
    callback = Q(callback);
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        <span class="keyword">return</span> callback.fcall().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> value;
        });
    }, <span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>TODO attempt to recycle the rejection with &quot;this&quot;.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">return</span> callback.fcall().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">throw</span> reason;
        });
    });
};

<span class="comment">/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */</span>
Q.done = <span class="function"><span class="keyword">function</span> <span class="params">(object, fulfilled, rejected, progress)</span> {</span>
    <span class="keyword">return</span> Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = <span class="function"><span class="keyword">function</span> <span class="params">(fulfilled, rejected, progress)</span> {</span>
    <span class="keyword">var</span> onUnhandledError = <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>forward to a future turn so that <code>when</code>
does not catch it and turn it into a rejection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            makeStackTraceLong(error, promise);
            <span class="keyword">if</span> (Q.onerror) {
                Q.onerror(error);
            } <span class="keyword">else</span> {
                <span class="keyword">throw</span> error;
            }
        });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Avoid unnecessary <code>nextTick</code>ing via an unnecessary <code>when</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> promise = fulfilled || rejected || progress ?
        <span class="keyword">this</span>.then(fulfilled, rejected, progress) :
        <span class="keyword">this</span>;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">"object"</span> &amp;&amp; process &amp;&amp; process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(<span class="keyword">void</span> <span class="number">0</span>, onUnhandledError);
};

<span class="comment">/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */</span>
Q.timeout = <span class="function"><span class="keyword">function</span> <span class="params">(object, ms, message)</span> {</span>
    <span class="keyword">return</span> Q(object).timeout(ms, message);
};

Promise.prototype.timeout = <span class="function"><span class="keyword">function</span> <span class="params">(ms, message)</span> {</span>
    <span class="keyword">var</span> deferred = defer();
    <span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        deferred.reject(<span class="keyword">new</span> Error(message || <span class="string">"Timed out after "</span> + ms + <span class="string">" ms"</span>));
    }, ms);

    <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, <span class="function"><span class="keyword">function</span> <span class="params">(exception)</span> {</span>
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */</span>
Q.delay = <span class="function"><span class="keyword">function</span> <span class="params">(object, timeout)</span> {</span>
    <span class="keyword">if</span> (timeout === <span class="keyword">void</span> <span class="number">0</span>) {
        timeout = object;
        object = <span class="keyword">void</span> <span class="number">0</span>;
    }
    <span class="keyword">return</span> Q(object).delay(timeout);
};

Promise.prototype.delay = <span class="function"><span class="keyword">function</span> <span class="params">(timeout)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
        <span class="keyword">var</span> deferred = defer();
        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            deferred.resolve(value);
        }, timeout);
        <span class="keyword">return</span> deferred.promise;
    });
};

<span class="comment">/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */</span>
Q.nfapply = <span class="function"><span class="keyword">function</span> <span class="params">(callback, args)</span> {</span>
    <span class="keyword">return</span> Q(callback).nfapply(args);
};

Promise.prototype.nfapply = <span class="function"><span class="keyword">function</span> <span class="params">(args)</span> {</span>
    <span class="keyword">var</span> deferred = defer();
    <span class="keyword">var</span> nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    <span class="keyword">this</span>.fapply(nodeArgs).fail(deferred.reject);
    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */</span>
Q.nfcall = <span class="function"><span class="keyword">function</span> <span class="params">(callback <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> args = array_slice(arguments, <span class="number">1</span>);
    <span class="keyword">return</span> Q(callback).nfapply(args);
};

Promise.prototype.nfcall = <span class="function"><span class="keyword">function</span> <span class="params">(<span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> nodeArgs = array_slice(arguments);
    <span class="keyword">var</span> deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    <span class="keyword">this</span>.fapply(nodeArgs).fail(deferred.reject);
    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */</span>
Q.nfbind =
Q.denodeify = <span class="function"><span class="keyword">function</span> <span class="params">(callback <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> baseArgs = array_slice(arguments, <span class="number">1</span>);
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> nodeArgs = baseArgs.concat(array_slice(arguments));
        <span class="keyword">var</span> deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        <span class="keyword">return</span> deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = <span class="function"><span class="keyword">function</span> <span class="params">(<span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> args = array_slice(arguments);
    args.unshift(<span class="keyword">this</span>);
    <span class="keyword">return</span> Q.denodeify.apply(<span class="keyword">void</span> <span class="number">0</span>, args);
};

Q.nbind = <span class="function"><span class="keyword">function</span> <span class="params">(callback, thisp <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> baseArgs = array_slice(arguments, <span class="number">2</span>);
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> nodeArgs = baseArgs.concat(array_slice(arguments));
        <span class="keyword">var</span> deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        <span class="function"><span class="keyword">function</span> <span class="title">bound</span><span class="params">()</span> {</span>
            <span class="keyword">return</span> callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        <span class="keyword">return</span> deferred.promise;
    };
};

Promise.prototype.nbind = <span class="function"><span class="keyword">function</span> <span class="params">(<span class="comment">/*thisp, ...args*/</span>)</span> {</span>
    <span class="keyword">var</span> args = array_slice(arguments, <span class="number">0</span>);
    args.unshift(<span class="keyword">this</span>);
    <span class="keyword">return</span> Q.nbind.apply(<span class="keyword">void</span> <span class="number">0</span>, args);
};

<span class="comment">/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */</span>
Q.nmapply = <span class="comment">// XXX As proposed by "Redsandro"</span>
Q.npost = <span class="function"><span class="keyword">function</span> <span class="params">(object, name, args)</span> {</span>
    <span class="keyword">return</span> Q(object).npost(name, args);
};

Promise.prototype.nmapply = <span class="comment">// XXX As proposed by "Redsandro"</span>
Promise.prototype.npost = <span class="function"><span class="keyword">function</span> <span class="params">(name, args)</span> {</span>
    <span class="keyword">var</span> nodeArgs = array_slice(args || []);
    <span class="keyword">var</span> deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    <span class="keyword">this</span>.dispatch(<span class="string">"post"</span>, [name, nodeArgs]).fail(deferred.reject);
    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */</span>
Q.nsend = <span class="comment">// XXX Based on Mark Miller's proposed "send"</span>
Q.nmcall = <span class="comment">// XXX Based on "Redsandro's" proposal</span>
Q.ninvoke = <span class="function"><span class="keyword">function</span> <span class="params">(object, name <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> nodeArgs = array_slice(arguments, <span class="number">2</span>);
    <span class="keyword">var</span> deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch(<span class="string">"post"</span>, [name, nodeArgs]).fail(deferred.reject);
    <span class="keyword">return</span> deferred.promise;
};

Promise.prototype.nsend = <span class="comment">// XXX Based on Mark Miller's proposed "send"</span>
Promise.prototype.nmcall = <span class="comment">// XXX Based on "Redsandro's" proposal</span>
Promise.prototype.ninvoke = <span class="function"><span class="keyword">function</span> <span class="params">(name <span class="comment">/*...args*/</span>)</span> {</span>
    <span class="keyword">var</span> nodeArgs = array_slice(arguments, <span class="number">1</span>);
    <span class="keyword">var</span> deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    <span class="keyword">this</span>.dispatch(<span class="string">"post"</span>, [name, nodeArgs]).fail(deferred.reject);
    <span class="keyword">return</span> deferred.promise;
};

<span class="comment">/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */</span>
Q.nodeify = nodeify;
<span class="function"><span class="keyword">function</span> <span class="title">nodeify</span><span class="params">(object, nodeback)</span> {</span>
    <span class="keyword">return</span> Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = <span class="function"><span class="keyword">function</span> <span class="params">(nodeback)</span> {</span>
    <span class="keyword">if</span> (nodeback) {
        <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
            nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                nodeback(<span class="literal">null</span>, value);
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
            nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                nodeback(error);
            });
        });
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>All code before this point will be filtered from stack traces.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> qEndingLine = captureLine();

<span class="keyword">return</span> Q;

}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
